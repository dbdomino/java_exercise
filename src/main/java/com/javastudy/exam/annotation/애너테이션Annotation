이게 뭔가?
주석처럼 프로그래밍 언어에 영향을 미치지 않으며, 유용한 정보를 제공함.
소스코드에 문서의 설명을 따로 만들기보다, 소스코드와 문서를 하나의 파일로 관리하도록 하려 생각 했다고 한다.
이를 위해
'/** ~~ */' 에 소스코드에 대한 정보를 저장하고
소스코드의 주석으로부터 HTML문서를 생성해내는 프로그램(javadoc.exe)을 만들어 사용했다고 한다.

'/**' 로 시작하는 주석 안에 소스코드에 대한 설명이 들어있고, 그 안에 '@'이 붙은 태그들이 눈에 띄는데
미리 정의된 태그들을 이용해서 주석 안에 정보를 저장하고, ,javadoc.exe라는 프로그램이 이 정보를 읽어서 문서를 작성하는데 사용한다.

이 기능을 응용하여, 프로그램의 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것이 바로 애너테이션 이다.
애너테이션은 주석(comment)처럼 프로그래밍 언어에 영향을 미치지 않으면서도 다른 프로그램에게 유용한 정보를 제공할 수 있다.

자바에서 기본적으로 제공하는 표준 애너테이션(*가 붙은 것은 메타 애너테이션)
@Override  컴파일러에게 오버라이딩하는 메서드라는 것을 알린다. 이거 없이도 오버라이딩 되지만, 컴파일러가 오버라이딩 되었는지 체크하도록 하는 것
            오버라이딩 하는것같으면 붙여주는게 좋다, 그래야 메소드 명에 오타 난 부분이 컴파일러에서 체크가 된다.
@Deprecated  앞으로 사용하지 않을 것을 권장하는 대상에 붙인다. 자바의 하위호환성 지원을 위해 존재, 해당 어노테이션이 붙은 코드를 컴파일하면, 경고 메시지가 나타남.
@SuppressWarnings  컴파일러의 특정 경고메시지가 나타나지 않게 해준다.
@Safe Varargs   지네릭스 타입의 가변인자에 사용한다.(JDK1.7)

@FunctionalInterface 함수형 인터페이스라는 것을 알린다.(JDK1.8) 컴파일러가 함수형 인터페이스를 올바르게 작성했는지 체크하는 어노테이션
                     함수형 인터페이스는 하나의 추상메서드만 가져야 하는 제약이 있는데, 이걸 확인해줌. (안붙여도 상관은 없으나 실수를 줄여줌, 함수형 인터페이스라고 알려주는 효과도 있음)
@Native              native 메서드에서 참조되는 상수 앞에 붙인다. (JDK1.8)

메타 애너테이션 (에너테이션 만들때 사용, java.lang.annotation 패키지에 포함)
@Target*        애너테이션이 적용가능한 대상을 지정하는데 사용한다.   (주요)
@Documented*    애너테이션 정보가 javadoc으로 작성된 문서에 포함되게 한다.
@Inherited*     애너테이션이 자손 클래스에 상속되도록 한다.
@Retention*     애너테이션이 유지되는 범위를 지정하는데 사용한다.     (주요)
@Repeatable*    애너테이션을 반복해서 적용할 수 있게 한다.(JDK1.8)
