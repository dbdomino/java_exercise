### TCP(Transmission Control Protocol)
- 특징
  - 연결 지향적 프로토콜 -> 시간 소요 (연결 성공이 필수이므로)
  - 통신 선로를 고정하므로 전송속도 느릴 수 있으나, 정확하고 안정적 전달
- java.net API
  - ServerSocket, Socket
- ServerSocket과 Socket 용도
  - 클라이언트가 서버에 연결 요청 하는게 Socket의 용도
  - ServerSocket으로 서버 포트와 주소를 bind시켜 accept()시킨다.
  - 이걸로 client의 응답을 받고, 요청을 보낼 수 있다.
  - 즉, **소켓통신** 구현 필요할때 이걸로 구현가능
### 스레드 병렬 처리 하기
- 블로킹(대기 상태)가 되는 메소드
  - ServerSocket의 accept() -> 실행되면 대기상태가 됨.
  - Socket 생성자 또는 connect() - > 실행되면 대기상태가 됨. 연결될때까지
  - Socket의 read(), write() -> 상대방이 데이터를 보내기 전까지 read() 유지, 데이터를 쓰는 write()동안 대기상태 유지
- 병렬 처리의 필요성
  - 스레드가 블로킹(대기상태) 되면 다른 작업을 수행하지 못한다.
    - 입출력 대기 동안 다른 클라이언트의 연결 요청을 수락하지 못한다.
    - 입출력 할 동안 다른 클라이언트의 입출력을 하지 못한다.
  - UI 생성/변경 스레드에서 블로킹 메소드를 호출하지 않도록 한다.
    - UI생성 및 변경이 안되고 이벤트 처리가 안된다.
- 스레드 병렬 처리
  - 서버에서 accept()를 계속 수행시킨다. 
  - 클라이언트에서 요청이 오면 accept()는 작업스래드를 생성해서 Socket 작업을 맡기고, 계속 accept() 를 수행한다.
  - 다른클라이언트에서 요청이오면 이를 반복한다.
  - 즉, accpet()만을 담당하는 thread가 있어야 한다.
- 병렬처리시 스레드 풀을 사용해서 스레드 수를 관리
  - 스레드 풀은 스레드 수를 제한해서 사용하기에
  - 클라이언트의 폭증과 요청이 늘어난다 해도, 작업큐에 작업이 쌓이며,
  - 스레드 수는 한계치 만큼만 계속 동작하며 요청을 처리한다.
  - 다만 대기하는 작업량이 많아지면 클라이언트에서 응답을 늦게 받을 수 있고, 요청이 너무많다면  QueueOverflow 발생 가능하다.